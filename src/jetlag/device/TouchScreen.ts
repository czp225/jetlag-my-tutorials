/**
 * TouchReceiver provides handlers to run in response to all of the gestures
 * that we care about.
 */
export interface TouchReceiver {
    tap(screenX: number, screenY: number): void;
    panStart(screenX: number, screenY: number): void;
    panMove(screenX: number, screenY: number): void;
    panStop(screenX: number, screenY: number): void;
    touchDown(screenX: number, screenY: number): void;
    touchUp(screenX: number, screenY: number): void;
    swipe(x0: number, y0: number, x1: number, y1: number, time: number): void;
}

/**
 * TouchScreen abstracts away how gestures (pan, swipe, tap, rotate, pinch, 
 * press) are generated by the device, and simply passes gesture events to
 * whatever object has subscribed to it.
 * 
 * Based on how Lol-TS is designed, we can get by with a single subscriber for
 * each gesture event
 */
export class TouchScreen {
    /** receiver handles all of the touch events */
    private receiver: TouchReceiver = null;

    /** The DOM element that receives gesture events */
    private elt: HTMLElement;

    /**
     * Create a TouchScreen by providing the name of an HTML element (typically
     * a DIV) that should begin receiving gestures.  Note that gestures will not
     * be handled until a TouchReceiver is provided.
     * 
     * @param domId The Id of the DOM element that will receive gesture events
     */
    constructor(domId: string) {
        this.elt = document.getElementById(domId);
    }

    /**
     * Connect the TouchScreen to the provided TouchReceiver, so that subsequent
     * touches will be routed *only* to that TouchReceiver
     * 
     * @param receiver The TouchReceiver that will handle subsequent gesture 
     *                 events.  If null is given, the previous receiver will be
     *                 used instead.
     */
    public setTouchReceiver(receiver: TouchReceiver) {
        // ignore null receivers...
        if (receiver === null)
            return;

        // Since we are using gestures, turn off left clicking of the whole page
        //
        // NB: only do this the first time a TouchReceiver is provided.
        if (this.receiver === null) {
            this.elt.oncontextmenu = function (this: HTMLElement, ev: PointerEvent): any {
                return false;
            }
        }
        this.receiver = receiver;

        // Set up handlers for all the Hammer events
        let hammer = new Hammer(this.elt);
        hammer.on('tap', (ev: HammerInput) => {
            this.receiver.tap((ev.srcEvent as PointerEvent).offsetX, (ev.srcEvent as PointerEvent).offsetY);
        });
        hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });
        hammer.on('panstart', (ev: HammerInput) => {
            this.receiver.panStart((ev.srcEvent as PointerEvent).offsetX, (ev.srcEvent as PointerEvent).offsetY);
        });
        hammer.on('panmove', (ev: HammerInput) => {
            this.receiver.panMove((ev.srcEvent as PointerEvent).offsetX, (ev.srcEvent as PointerEvent).offsetY);
        });
        hammer.on('panend', (ev: HammerInput) => {
            this.receiver.panStop((ev.srcEvent as PointerEvent).offsetX, (ev.srcEvent as PointerEvent).offsetY);
        });
        hammer.on('pancancel', (ev: HammerInput) => {
            this.receiver.panStop((ev.srcEvent as PointerEvent).offsetX, (ev.srcEvent as PointerEvent).offsetY);
        });

        // this gets us 'downpress' and 'release'.  See "input events" on http://hammerjs.github.io/api/
        hammer.on("hammer.input", (ev: HammerInput) => {
            if (ev.eventType == 1) {
                this.receiver.touchDown((ev.srcEvent as PointerEvent).offsetX, (ev.srcEvent as PointerEvent).offsetY);
            }
            else if (ev.eventType == 4) {
                this.receiver.touchUp((ev.srcEvent as PointerEvent).offsetX, (ev.srcEvent as PointerEvent).offsetY);
            }
        });
        // NB: swipe also registers pans.
        // NB: there is swipeup, swipeleft, swiperight, swipedown
        hammer.on('swipe', (ev: HammerInput) => {
            this.receiver.swipe(ev.center.x - ev.deltaX, ev.center.y - ev.deltaY, ev.center.x, ev.center.y, ev.deltaTime);
        });
        hammer.get('swipe').set({ direction: Hammer.DIRECTION_ALL });
    }
}